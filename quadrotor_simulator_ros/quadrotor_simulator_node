#!/usr/bin/env python3

import os
import numpy as np
import time

import rclpy
from rclpy.node import Node
from tf2_msgs.msg import TFMessage
from geometry_msgs.msg import TransformStamped, Transform
import ament_index_python
from visualization_msgs.msg import Marker, MarkerArray
from geometry_msgs.msg import Point

from rosbags.rosbag1 import Reader
from rosbags.serde import deserialize_cdr, ros1_to_cdr
from rosbags.typesys import get_types_from_msg, register_types

from quadrotor_simulator_py.quadrotor_model import QuadrotorModel
from quadrotor_simulator_py.quadrotor_control import QuadrotorPositionControllerPD
from quadrotor_simulator_py.quadrotor_control import QuadrotorAttitudeControllerPD
from quadrotor_simulator_py.quadrotor_control import State

def get_pose_rpm_messages(bagfilepath):
    typs = {}
    reader = None
    with Reader(bagfilepath) as reader:
        for conn in reader.connections:
            typs.update(get_types_from_msg(conn.msgdef, conn.msgtype))
            register_types(typs)

    reader.open()
    msgs = []
    connections = [
        x for x in reader.connections if (x.topic == "quadrotor_msgs/msg/StateSpace")]

    for idx, (connection, timestamp, rawdata) in enumerate(reader.messages(connections=connections)):
        msgs.append(deserialize_cdr(ros1_to_cdr(
            rawdata, connection.msgtype), connection.msgtype))

    return msgs

def get_tracking_error_messages(bagfilepath):
    typs = {}
    reader = None
    with Reader(bagfilepath) as reader:
        for conn in reader.connections:
            typs.update(get_types_from_msg(conn.msgdef, conn.msgtype))
            register_types(typs)

    reader.open()
    msgs = []
    connections = [
        x for x in reader.connections if (x.topic == "/rocky0704/motion_manager/tracking_error")]

    for idx, (connection, timestamp, rawdata) in enumerate(reader.messages(connections=connections)):
        msgs.append(deserialize_cdr(ros1_to_cdr(
            rawdata, connection.msgtype), connection.msgtype))

    return msgs

def to_sec(header):
    return header.stamp.sec + header.stamp.nanosec*1e-9


def extract_time(msg):
    return to_sec(msg.header)


def sort_messages(msgsin):

    # First check to see if the messages are in order
    msgsout = []
    for msg in msgsin:
        if msg.__msgtype__ == 'quadrotor_msgs/msg/TrackingError':
            msgsout.append(msg)
    msgsout.sort(key=extract_time)
    return msgsout

def tracking_error_msg_to_desired_state(msg):
    s = State()
    s.pos = np.reshape([msg.pos_des.x, msg.pos_des.y, msg.pos_des.z], (3, 1))
    s.vel = np.reshape([msg.vel_des.x, msg.vel_des.y, msg.vel_des.z], (3, 1))
    s.acc = np.reshape([msg.acc_des.x, msg.acc_des.y, msg.acc_des.z], (3, 1))
    s.jerk = np.reshape(
        [msg.jerk_des.x, msg.jerk_des.y, msg.jerk_des.z], (3, 1))
    s.snap = np.reshape(
        [msg.snap_des.x, msg.snap_des.y, msg.snap_des.z], (3, 1))
    s.yaw = msg.yaw_des
    s.dyaw = msg.yawdot_des
    return s

class QuadrotorSimulatorNode(Node):
    def __init__(self):
        super().__init__('quadrotor_simulator_node')
        self.marker_array_pub = self.create_publisher(MarkerArray, "/trajectory", 10)
        self.marker_array = MarkerArray()

        # initialize TF frames
        self.fixed_frame_id = 'world'
        self.base_frame_id = 'body'

        # initialize Quadrotor Model
        self.model = QuadrotorModel()
        model_config_file = os.path.join(ament_index_python.get_package_share_directory(
            'quadrotor_simulator_py'), 'config/rocky0704_model_params.yaml')
        self.model.initialize(model_config_file)

        posctl = QuadrotorPositionControllerPD(model_config_file)
        attctl = QuadrotorAttitudeControllerPD(model_config_file)


        # create odom and transform publishers
        self.tf_pub = self.create_publisher(TFMessage, "/tf", 10)

        # Load bagfile
        cwd = os.getcwd()
        bagfilepath = None
        bagfilename = "room_2023-05-22-13-29-19.bag"
        sandbox = "quadrotor_simulator_ws"
        if sandbox in cwd:
            bagfilepath = cwd.split(sandbox)
            bagfilepath = bagfilepath[0] + sandbox + "/data/" + bagfilename
            self.get_logger().info(bagfilepath)
        else:
            raise Exception(
                "quadrotor_simulator_ws not found in current path.")

        # read the messages from the bag file in sorted order
        #msgs = get_pose_rpm_messages(bagfilepath)
        msgs = get_tracking_error_messages(bagfilepath)
        sorted_msgs = sort_messages(msgs)

        prev_time = extract_time(sorted_msgs[0])
        prev_translation = [0., 0., 0.]
        for idx, msg in enumerate(sorted_msgs):
            if msg.__msgtype__ == 'quadrotor_msgs/msg/TrackingError':

                start = time.time()
                ts = TransformStamped()
                ts.transform = Transform()

                state_des = tracking_error_msg_to_desired_state(msg)
                posctl.set_current_state(self.model.get_state())
                posctl.set_reference_state(state_des)
                posctl.run_ctrl()

                casc_cmd = posctl.get_cascaded_command()

                attctl.set_cascaded_cmd(casc_cmd)
                curr_state = self.model.get_state()
                attctl.set_current_state(self.model.get_state())
                uRPM = attctl.run_ctrl().tolist()
                self.model.apply_command(uRPM)
                self.model.update(to_sec(msg.header))

                Twb = self.model.get_pose()

                translation = Twb.translation()
                ts.transform.translation.x = translation[0]
                ts.transform.translation.y = translation[1]
                ts.transform.translation.z = translation[2]

                quaternion = Twb.quaternion()
                ts.transform.rotation.w = quaternion[0]
                ts.transform.rotation.x = quaternion[1]
                ts.transform.rotation.y = quaternion[2]
                ts.transform.rotation.z = quaternion[3]

                ts.header.stamp = self.get_clock().now().to_msg()
                ts.header.frame_id = self.fixed_frame_id
                ts.child_frame_id = self.base_frame_id

                if idx % 12 == 0:
                    marker = Marker()
                    marker.header.frame_id = "/world"
                    marker.type = marker.LINE_STRIP
                    marker.action = marker.ADD
                    marker.scale.x = 0.05
                    marker.scale.y = 0.05
                    marker.scale.z = 0.05
                    marker.color.a = 1.0
                    marker.color.r = 0.0
                    marker.color.g = 0.0
                    marker.color.b = 1.0
                    marker.pose.orientation.w = 1.0
                    marker.pose.orientation.x = 0.0
                    marker.pose.orientation.y = 0.0
                    marker.pose.orientation.z = 0.0

                    t1 = Point()
                    t1.x = prev_translation[0]
                    t1.y = prev_translation[1]
                    t1.z = prev_translation[2]
                    marker.points.append(t1)

                    t2 = Point()
                    t2.x = translation[0]
                    t2.y = translation[1]
                    t2.z = translation[2]
                    marker.points.append(t2)
                    marker.id = idx

                    marker.header.stamp = self.get_clock().now().to_msg()
                    self.marker_array.markers.append(marker)

                    self.marker_array_pub.publish(self.marker_array)
                    prev_translation = translation

                    self.get_logger().info(str(len(self.marker_array.markers)))

                end = time.time()
                if (end-start) < (extract_time(msg)-prev_time):
                    time.sleep( (extract_time(msg)-prev_time) - (end-start) )

                prev_time = extract_time(msg)

                tf_msg = TFMessage(transforms=[ts])
                self.tf_pub.publish(tf_msg)


def main(args=None):
    rclpy.init(args=args)

    qsimnode = QuadrotorSimulatorNode()

    rclpy.spin(qsimnode)


if __name__ == '__main__':
    main()
